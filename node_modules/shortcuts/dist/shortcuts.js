"use strict";
/* IMPORT */
Object.defineProperty(exports, "__esModule", { value: true });
var enums_1 = require("./enums");
var listener_1 = require("./listener");
var shortcut_1 = require("./shortcut");
var utils_1 = require("./utils");
/* SHORTCUTS */
var Shortcuts = /** @class */ (function () {
    function Shortcuts(options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        this.handler = function (id, event) {
            if (_this.recordHandler) { // Recording
                _this.recordHandler(shortcut_1.default.id2accelerator(id));
                return enums_1.ListenerResult.UNHANDLED;
            }
            var handleable = false, firstHandleableIndex = -1;
            outer: for (var i = 0, l = id.length; i < l; i++) { // Trying all possible combinations (e.g 'A B C' => ['A B C', 'B C ', 'C'])
                var target = _this.shortcuts;
                for (var ci = i; ci < l; ci++) { // Getting all chords in the current combination
                    target = target[id[ci]];
                    if (!target) {
                        if (!handleable && i === (l - 1))
                            return enums_1.ListenerResult.UNHANDLEABLE; // Can't be handled by any deeper shortcuts
                        continue outer;
                    }
                }
                handleable = true;
                if (firstHandleableIndex === -1)
                    firstHandleableIndex = i;
                var handlers = target.handlers;
                for (var hi = 0, hl = handlers.length; hi < hl; hi++) {
                    if (handlers[hi](event) === true) { // Handled, stopping here
                        if (event) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                        return enums_1.ListenerResult.HANDLED;
                    }
                }
            }
            if (firstHandleableIndex > 0)
                return id.slice(firstHandleableIndex); // Simplifying the shortcut, no point in checking unhandleable combinations
            return enums_1.ListenerResult.UNHANDLED;
        };
        this.listener = new listener_1.default({
            capture: options.capture,
            handler: this.handler,
            target: options.target,
            shouldHandleEvent: options.shouldHandleEvent
        });
        this.reset();
        if (options.shortcuts) {
            this.add(options.shortcuts);
        }
    }
    Shortcuts.prototype._updateListener = function () {
        var shouldListen = !!this.shortcuts.size;
        if (shouldListen === this.listener.isListening())
            return;
        shouldListen ? this.listener.on() : this.listener.off();
    };
    Shortcuts.prototype.get = function () {
        return this.descriptors;
    };
    Shortcuts.prototype.add = function (descriptors) {
        var _this = this;
        if (!(descriptors instanceof Array))
            return this.add([descriptors]);
        descriptors.forEach(function (descriptor) {
            var shortcut = descriptor.shortcut, handler = descriptor.handler;
            if (shortcut[0] === '-')
                return _this.remove([{ shortcut: shortcut, handler: handler }]);
            if (!handler)
                return console.error("Can't add shortcut \"" + shortcut + "\" which has no handler");
            var id = shortcut_1.default.shortcut2id(shortcut);
            // if ( !Shortcut.checkValidID ( id ) ) return; //TODO: Maybe enable this check, sacrificing some performance for some user friendliness
            _this.descriptors.push(descriptor);
            var lastIndex = id.length - 1;
            id.reduce(function (parent, id, index) {
                if (!parent[id]) {
                    parent.size++;
                    parent[id] = {
                        parent: parent,
                        id: id,
                        size: 0,
                        handlers: []
                    };
                }
                if (index === lastIndex) {
                    parent[id].handlers.unshift(handler);
                }
                return parent[id];
            }, _this.shortcuts);
        });
        this._updateListener();
    };
    Shortcuts.prototype.remove = function (descriptors) {
        var _this = this;
        if (!(descriptors instanceof Array))
            return this.remove([descriptors]);
        descriptors.forEach(function (descriptor) {
            var shortcut = descriptor.shortcut, handler = descriptor.handler;
            if (shortcut[0] === '-')
                shortcut = shortcut.slice(1);
            var id = shortcut_1.default.shortcut2id(shortcut);
            // if ( !Shortcut.checkValidID ( id ) ) return; //TODO: Maybe enable this check, sacrificing some performance for some user friendliness
            _this.descriptors = _this.descriptors.filter(function (d) { return (d.shortcut !== shortcut && !utils_1.default.isEqual(shortcut_1.default.shortcut2id(d.shortcut), id)) || (handler && d.handler !== handler); });
            var lastIndex = id.length - 1;
            id.reduce(function (parent, id, index) {
                var child = parent[id];
                if (!child)
                    return {};
                if (index === lastIndex) {
                    if (handler) {
                        child.handlers = child.handlers.filter(function (h) { return h !== handler; });
                    }
                    else {
                        child.handlers.length = 0;
                    }
                    var target = child;
                    while (!target.size && !target.handlers.length && target.parent && target.id) { // Cleaning up
                        delete target.parent[target.id];
                        target.parent.size--;
                        target = target.parent;
                    }
                }
                return child;
            }, _this.shortcuts);
        });
        this._updateListener();
    };
    Shortcuts.prototype.reset = function () {
        this.descriptors = [];
        this.shortcuts = {
            size: 0,
            handlers: []
        };
        this._updateListener();
    };
    Shortcuts.prototype.record = function (handler) {
        var _this = this;
        this.recordHandler = handler;
        return function () { return delete _this.recordHandler; };
    };
    Shortcuts.prototype.trigger = function (shortcut) {
        var id = typeof shortcut === 'string' ? shortcut_1.default.shortcut2id(shortcut) : shortcut;
        // if ( !Shortcut.checkValidID ( id ) ) return ListenerResult.UNHANDLEABLE; //TODO: Maybe enable this check, sacrificing some performance for some user friendliness
        return this.handler(id) === enums_1.ListenerResult.HANDLED;
    };
    return Shortcuts;
}());
/* EXPORT */
exports.default = Shortcuts;
